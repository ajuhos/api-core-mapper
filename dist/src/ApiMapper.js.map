{"version":3,"file":"ApiMapper.js","sourceRoot":"","sources":["../../src/ApiMapper.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    Api, ApiEdgeDefinition, ApiEdgeMethod, ApiEdgeRelation, ApiEdgeMethodScope,\n    OneToOneRelation, OneToManyRelation\n} from \"api-core\";\n\nexport class ApiMapper {\n\n    levelLimit: number = 2;\n    private api: Api;\n\n    constructor(api: Api) {\n        this.api = api\n    }\n\n    private printRoutesSingular = (edge: ApiEdgeDefinition, prefix = \"\", level = 1): string[] => {\n        if(level > this.levelLimit) return [];\n\n        let output = [\n            `${prefix}`\n        ];\n\n        edge.methods.forEach(\n            (method: ApiEdgeMethod) => {\n                if(method.scope == ApiEdgeMethodScope.Entry || method.scope == ApiEdgeMethodScope.Collection) {\n                    output.push(`${prefix}/${method.name}`)\n                }\n            });\n\n        edge.relations\n            .filter((relation: ApiEdgeRelation) => relation.from == edge)\n            .forEach((relation: ApiEdgeRelation) => {\n                if(relation instanceof OneToOneRelation) {\n                    output = output.concat(\n                        this.printRoutesSingular(relation.to, `${prefix}/${relation.name}`, level + 1))\n                }\n                else {\n                    output = output.concat(\n                        this.printRoutes(relation.to, `${prefix}/${relation.name}`, level + 1))\n                }\n            });\n\n        return output\n    };\n\n    private printRoutes = (edge: ApiEdgeDefinition, prefix = \"\", level = 1): string[] => {\n        if(level > this.levelLimit) return [];\n\n        let output = [\n            `${prefix}`,\n            `${prefix}/:${edge.idField}`\n        ];\n\n        edge.methods.forEach(\n            (method: ApiEdgeMethod) => {\n                if(method.scope == ApiEdgeMethodScope.Collection || method.scope == ApiEdgeMethodScope.Edge) {\n                    output.push(`${prefix}/${method.name}`)\n                }\n\n                if(method.scope == ApiEdgeMethodScope.Entry || method.scope == ApiEdgeMethodScope.Edge) {\n                    output.push(`${prefix}/:${edge.idField}/${method.name}`)\n                }\n            });\n\n        edge.relations\n            .filter((relation: ApiEdgeRelation) => relation.from == edge)\n            .forEach((relation: ApiEdgeRelation) => {\n                if(relation instanceof OneToOneRelation) {\n                    output = output.concat(\n                        this.printRoutesSingular(relation.to, `${prefix}/:${edge.idField}/${relation.name}`, level + 1))\n                }\n                else {\n                    output = output.concat(\n                        this.printRoutes(relation.to, `${prefix}/:${edge.idField}/${relation.name}`, level + 1))\n                }\n            });\n\n        return output\n    };\n\n    private mapEdge = (edge: ApiEdgeDefinition) => {\n        return this.printRoutes(edge, `/${edge.pluralName}`);\n    };\n\n    map = () => {\n        let output: string[] = [];\n\n        this.api.edges.forEach((edge: ApiEdgeDefinition) => {\n            this.mapEdge(edge).forEach((route: string) => {\n                if(output.indexOf(route) == -1)\n                    output.push(route)\n            })\n        });\n\n        return output\n    }\n\n}\n"]}